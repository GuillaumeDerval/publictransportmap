{\rtf1\ansi\ansicpg1252\cocoartf1671
{\fonttbl\f0\fnil\fcharset0 Calibri-Bold;}
{\colortbl;\red255\green255\blue255;\red42\green44\blue46;\red255\green255\blue255;\red32\green105\blue220;
}
{\*\expandedcolortbl;;\cssrgb\c21569\c22745\c23529;\cssrgb\c100000\c100000\c100000;\cssrgb\c15294\c50196\c89020;
}
\deftab720
\pard\pardeftab720\sl360\sa240\qj\partightenfactor0

\f0\b\fs30 \cf2 \cb3 \expnd0\expndtw0\kerning0
TL;DR:\'a0I downloaded the timetables for all the public transport providers in Belgium (SNCB/NMBS, TEC, STIB/MIVB, De Lijn), and\'a0simply\'a0computed the shortest path from all the stations to everywhere.\
If you are a computer scientist or an enthusiast, here is a bit more detailed summary of what I did:\'a0I first downloaded the\'a0{\field{\*\fldinst{HYPERLINK "https://developers.google.com/transit/gtfs/"}}{\fldrslt \cf4 GTFS}}\'a0feeds from all the providers in Belgium (SNCB/NMBS, TEC, STIB/MIVB, De Lijn). There are\'a070730 bus/train stops in Belgium, and\'a01756585 connections per day\'a0(movements of a bus/train/... between two stops). This is true for a specific day, the 18/07/19, which is the base of this analysis.\
This forms a nice graph, with 70k nodes and 1.7M edges. Computing the time to reach every node from a specific one, is not, however, as simple as running a shortest path algorithm (such as\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"}}{\fldrslt \cf4 Dijkstra's}}); as the edges available to move from one node to another depends on the time: a train only leaves a station at a specific time, not at every instant.\
We then need a node for each stop, and for each time a bus/train/... departs or arrives at this specific stop. This is called the\'a0time-expanded graph\'a0in the literature. The good news is that now, we can run traditional shortest-path algorithms. The bad one is that, well, the new graph has\'a01.789.163\'a0nodes.\
This obviously is not a trivial size for a graph. However, it falls completely in the "doable" category, even on my laptop. In order to win some time, I use the fact that the time is strictly going in a single direction (the TEC does not have DeLorean busses sadly): having the topological sort is free of charge, and the shortest paths can then be computed in O(V+E).\
Sadly, there is still a catch: if you run the algorithm as-is, you will probably not be able to reach anywhere, as we did not took into account the fact that you can actually walk between two bus/train/... stops. This is actually pretty important, as not allowing walking prevents you from going to a train stop to a bus stop, or even to go to the other side of the road to catch a different bus.\
This heavily complexifies the problem! It basically means that now each node of the (initial, non-time-expanded) graph has a link to all the other nodes (the path by foot), i.e. there are 5 billions edges in the graph. Moreover, I do not know how I could compute easily all those paths. Should we use Openstreetmap and compute the effective paths?\
This is, by far, too complex. I thus decided to simplify things a bit. First, we will limit the maximum walk time between two stops at 30 minutes. That means that if two bus stops are 31 minutes apart by foot, you cannot go there without using an intermediate bus stop, or by taking some form of transport. This limit the degree of the nodes in the graph to something more reasonable.\
The other simplification is that I compute all walk path "as the crow flies", not taking into account the roads, street, or other things. This allow to use a simple euclidian distance computation. I consider that everyone walks at 3km/h "as the crow flies". Why 3km/h?\'a0{\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Walking"}}{\fldrslt \cf4 I trust Wikipedia that says we walk more or less at 5 km/h}}. However, that does not take into account the time that you spend to get around building and waiting for traffic lights to become green. Downscaling this speed is then needed, and I chose 3km/h for this reason. It is, of course, somewhat arbitrary.\
By adding these walk times to the graph (precomputed once for all bus/train/... stops), the graph is now bigger, but it is still ok for my (not-so-small) laptop. The next step is super simple: for each time step, we indicate that the node "start station, time step" is at distance 0. We then run the shortest path algorithm. The optimal time to reach another bus/train/... stop is then the minimum, over all time steps, of the distance to the nodes representing the stop in the time-expanded graph.\
I decided to run this for all the train stations in Belgium (600 in total). In order to win time, I used a server that I use for my research at UCLouvain (thanks, Pierre & Siegfried!).\
Still following me? Good. Now we have, for each train station in Belgium, the minimum time to reach every bus/train/... stop. Now we need to draw a map from this. This was actually more complex for me (I'm more into OR/combinatorial optimization than GIS) and I'm not sure I chose the easiest way. What I decided to do is to produce a polygon for each threshold of 10 minutes. The boundary of the polygon with threshold X is the set of points that can be reached exactly in X minutes.\
Computing this is straightforward. Let us say we have a threshold X. Take all the stops that can be reached before X. For each stop respecting this condition, draw a circle around it. The radius of the circle, is, for a stop that can be reached at minute Y, the distance that can be travelled in X-Y minutes. The polygon (yes, I discretize a bit things here) for the threshold X is simply the union of all the circles. We can then simply display them on a map!\
}